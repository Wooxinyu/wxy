### define

### typedef


### volatile

voligate 本意易变得，因为访问寄存器要比访问内存要快得多，所以编译器一般会做减少存取内存得优化，但有可能会读“脏数据”。当要求使用 voligate 关键字时，系统会重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确的说，遇到这个关键字声明的变量，编译器对访问该变量的代码就不会进行优化，从而可以提供对特殊地址的访问。如果不使用 voligate，则不会对该代码进行优化。

可能造成内存中的值与寄存器中的值不同的原因：
**1. i 是其他子线程与主线程共享的全局变量，其他子线程有可能修改 i 值；**

**2. i 是中断函数与主函数共享的全局变量，中断函数有可能修改 i 值；**

**3. i 属于硬件寄存器，CPU可能通过硬件直接改变 i 的值（例如寄存器的标志位）**
## 理解
在编译时，为了增加程序的运行速度，会将一些经常使用的变量存放在寄存器而不是内存当中，在读取数据时就可以直接从寄存器中读取。但有些变量会变更的很频繁，存放在寄存器时可能这个变量的值已经改变了，但寄存器中没有更新，以至于拿到错误的值，使用 voligate 关键字后，就会始终从内存中获取数据，而不能重复使用放在 chche 或寄存器中的备份，可以避免上述存在的问题。
## 参考 
百度文库： https://wenku.baidu.com/view/9ec1690eee06eff9aef80745.html?_wkts_=1677153432727&bdQuery=c%E8%AF%AD%E8%A8%80+voliate%E5%85%B3%E9%94%AE%E5%AD%97
CSDN： https://blog.csdn.net/u010134355/article/details/125058164

### pragam

```
#pargma 作用是设定编译器的状态或者是指示编译器完成一些特定的动作
格式一般为 #pragma Para
fromModule=lemma_inlink) pack(push) //保存对齐状态
#pragma pack(n)//设定为n[字节对齐]
合法的数值分别是1，2，4，8，16.
#pragma pack(pop)//恢复对齐状态
```

# 参考
 百度百科： https://baike.baidu.com/item/%23pragma%20pack/3338249?fr=aladdin
### const



### sizeof


### strlen



