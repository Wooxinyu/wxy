## IIC 总线
IIC（又称 I 2 C，Inter-Integrated Circuit），即集成电路总线，是一种两线式串行总线，由 PHILIPS 公司开发，用于连接微控制器及其外围设备。多用于主机和从机在数据量不大且传输距离短的场合下的主从通信。I 2 C 总线由数据线 SDA 和时钟线 SCL 构成通信线路，既可用于发送数据，也可接收数据，是一种半双工通信协议。总线上的主设备与从设备之间以字节 (8 位)为单位进行双向的数据传输。

IIC 有 3 种传输模式：

标准模式：100 K bit/s
快速模式：400 K bit/s
高速模式：3.4 M bit/s
主机启动总线，并产生时钟用于传送数据，此时任何接收数据的器件均被认为是从机。IIC 器件一般采用开漏结构与总线相连，所以 I IC_SCL 和 IIC_SDA 均需接上拉电阻，也正因此，当总线空闲时，这两条线路都处于高电平状态，当连到总线上的任一器件输出低电平，都将使总线拉低。
总线上的每一个设备都可以作为主设备或者从设备，且每一个设备都会对应一个唯一的地址，主从设备通过这个地址来识别确定与哪个设备进行通信。


本文所用程序为正点原子的 IIC 软件仿真。
### 总线 (物理)
IIC 由两条线组成，其中一条时钟线 SCL，一条数据线 SDA。
多用于主机和从机在**数据量不大**且**传输距离短**的场合下的主从通信。I2C总线由**数据线SDA**_和_**时钟线SCL**_构成通信线路，既可用于发送数据，也可接收数据，是一种**半双工通信协议**。总线上的主设备与从设备之间以字节(8位)为单位进行双向的数据传输。
### 通信流程
1、主机发送起始信号用于启用总线
2、主机发送一个字节数据指明从机地址和后续字节的传输方向
3、被寻址的从机发送应答信号回应主机
4、发送器发送要读写的寄存器地址
5 从机返回应答信号
6、发送器发送一个数据
7、接收器发送应答信号回应

n、通信结束，主机发送停止信号。
### 空闲状态
在没有通信产生时，两条线均为高电平，此时处于空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。

### 起始信号
需要发起通信的主站在发起通信时，在时钟有效期 (时钟线为高电平)内将数据线电平由高置低，以表示有人要开启通信，同时其他从站发现有人在占用总线发起通信，便开始进入等待通信主站下一条地址信号的状态。在发起起始信号前要保证总线处于空闲状态。
![](IIC_主站通信模拟_image_1.png)
#### 程序
在开始时先将数据与时钟引脚置高，确保总线已经处于空闲状态，延时一定时间后拉低数据线发出起始信号。时钟维持一段时间后将时钟线拉低，使其他信号无效。
```c
//产生IIC起始信号
void IIC_Start(void)
{
	SDA_OUT();     //sda线输出
	IIC_SDA=1;	  	  
	IIC_SCL=1;
	delay_us(4);
 	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
	delay_us(4);
	IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 
}	  
```
### 停止信号
在通信结束后，由主站发起停止信号，标志一次通信的终止。
停止信号是在时钟有效时，将数据线由低拉高，表示这次通信的结束。
发出该信号后，IIC 总线返回空闲状态。
![](IIC_主站通信模拟_image_2.png)
#### 程序
在开始时先将数据引脚置低，短暂延时后将时钟线拉高，将数据线拉高，发出停止信号。
并将时钟信号一直保持高状态，此时进入空闲状态。
```c
//产生IIC停止信号
void IIC_Stop(void)
{
	SDA_OUT();//sda线输出
	IIC_SCL=0;
	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
 	delay_us(4);
	IIC_SCL=1; 
	IIC_SDA=1;//发送I2C总线结束信号
	delay_us(4);							   	
}
```
### 发送数据
数据线在时钟有效时是不能改变数据线的电平状态的，因此要在时钟信号无效时就将数据线电平置于需要的状态，然后拉高时钟线，在时钟线无效前数据线要一直保持。在时钟无效后才可以开始变换。每次数据发送是以字节为单位。即每次发送要调整数据线引脚 8 次。
![](IIC_主站通信模拟_image_3.png)
#### 程序
输入参数为需要发送的字节
 在改变数据线前将时钟线拉低，以保证数据线可以安全改变。IIC 总线是从一个字节的最高位开始传播。因此采用通过与获取最高位后右移 7 位的方式获取最高位，然后将发送字节向左移一位，使此时字节的最高位为应发字节的第七位。
 得到最高位后改变数据线，然后使时钟有效并保持至少设备的最低频率。然后使时钟无效，开始下一位的传输。
 
```c
//IIC发送一个字节
		  
void IIC_Send_Byte(u8 txd)
{                        
    u8 t;   
	SDA_OUT(); 	    
    IIC_SCL=0;//拉低时钟开始数据传输
    for(t=0;t<8;t++)
    {              
        IIC_SDA=(txd&0x80)>>7;
        txd<<=1; 	  
		delay_us(2);   //对TEA5767这三个延时都是必须的
		IIC_SCL=1;
		delay_us(2); 
		IIC_SCL=0;	
		delay_us(2);
    }	 
} 	   
```
### 接收数据
读入数据的流程与发送数据相反，即在时钟有效期时读入数据线上的电平信号，并写到对应的缓冲区内。在接收到一个完整的字节后按照具体情况选择是否要发送应答信号。 
#### 程序
先将时钟线置低一段时间使从机可以改变数据线上的值，随后拉高时钟线使主机可以读取此时数据线上的数据值。如果为高则加一，然后将接收缓冲区左移一位。以及循环 8 次知道读取一个完整的字节。
```c
//读1个字节，ack=1时，发送ACK，ack=0，发送nACK   
u8 IIC_Read_Byte(unsigned char ack)
{
	unsigned char i,receive=0;
	SDA_IN();//SDA设置为输入
    for(i=0;i<8;i++ )
	{
        IIC_SCL=0; 
        delay_us(2);
		IIC_SCL=1;
        receive<<=1;
        if(READ_SDA)receive++;   
		delay_us(1); 
    }					 
    if (!ack)
        IIC_NAck();//发送nACK
    else
        IIC_Ack(); //发送ACK   
    return receive;
}

```


### 发送应答信号
在接收器接收到传输的字节后，接收器需要向总线释放应答信号表示已经接收到这次字节传送。
在接收完数据的下一个时钟有效期内，如果数据线电平为低则为应答信号，数据线电平为高则为非应答信号。
当接收器接受完所有的信息时需发送一个非应答信号，表示所有数据均已接收。主站可以发送停止信号结束本次通信。
![](IIC_主站通信模拟_image_4.png)
#### 程序
在时钟无效时根据是否应答将数据线置于相应电平，时钟有效后维持，最后将时钟无效表示这次应答结束。
```c
void IIC_Ack(void)
{
	IIC_SCL=0;
	SDA_OUT();
	IIC_SDA=0;
	delay_us(2);
	IIC_SCL=1;
	delay_us(2);
	IIC_SCL=0;
}
//不产生ACK应答		    
void IIC_NAck(void)
{
	IIC_SCL=0;
	SDA_OUT();
	IIC_SDA=1;
	delay_us(2);
	IIC_SCL=1;
	delay_us(2);
	IIC_SCL=0;
}			
```
### 等待应答信号 
主站在发送完数据后需要进入等待应答信号状态，等待从机发送应答信号或者非应答信号，来确定传输下一个字节或者停止这次通信。
如果在等待应答信号期间发生了超时，也没有接收到从机发送的低电平应答信号，则视为接收到了非应答信号，结束本次通信。
#### 程序
主站拉高时钟电平，然后等待从站在数据线上的应答信号。如果读到数据线变为低电平，则拉低时钟，返回接收到了应答信号，开始下一步的通信。如果在时限内数据线始终为高电平，则从站返回的为非应答信号。此时结束此次 IIC 通信，返回未接收到应答信号。
```c
//等待应答信号到来
//返回值：1，接收应答失败
//        0，接收应答成功
u8 IIC_Wait_Ack(void)
{
	u8 ucErrTime=0;
	SDA_IN();      //SDA设置为输入  
	IIC_SDA=1;delay_us(1);	   
	IIC_SCL=1;delay_us(1);	 
	while(READ_SDA)
	{
		ucErrTime++;
		if(ucErrTime>250)
		{
			IIC_Stop();
			return 1;
		}
	}
	IIC_SCL=0;//时钟输出0 	   
	return 0;  
} 
```

