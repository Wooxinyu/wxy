# 任务调度
## 任务调度
	
任务调度器又叫调度程序，scheduler。负责确定下一个要运行的任务。

uc/os iii为可剥夺式的内核，总会运行处于就绪状态下优先级最高的任务。当优先级最高的任务进入延时状态或等待状态后，就会进行任务调度，运行其他处于就绪态且优先级最高的任务。

为了减少中断服务程序运行的时间，一般在ISR中只是释放一个信号量，以此唤醒真正的中断处理任务。 在中断结束后会先运行优先级更高的中断处理任务，在中断处理任务运行结束再次进入等待态后才会返回被中断的任务。
如果有创建中断服务管理任务，则会将释放的信号量存在一个特殊的缓冲器内，在中断结束后由管理任务释放这些信号量。

## 调度点
### 当前任务优先级不为最高
当前运行的任务被删除
当前运行的任务被挂起
当前任务优先级被改变为不为就绪中最高的
当前任务改变其他就绪态任务的优先级使其比自己高
当前任务解除高优先级任务的挂起
当前任务进入等待/延时 态
当前任务释放信号使高优先级任务推出等待态
### 高优先级任务退出等待/延时态进入就绪态
高优先级的等待态任务等到东西了
高优先级的等待态任务延时结束了
高优先级的等待态任务等的东西被删除了
### 其他
退出所有的嵌套中断，中断服务程序有可能释放信号量唤醒高优先级任务
给调度器解锁




## 时间片轮转
可以给任务配置时间片的大小，即这个任务可以运行多少个时钟节拍的长度。
同一优先级下的任务采用时间片轮转的方式轮流使用CPU
当前任务可以主动放弃它剩余的时间片 OSSchedRoundRobinYield


## 调度的实现
### OSSched()
#OSSched
不可用于中断中
检测是否还处在中断中
确认调度器没有上锁
找到优先就绪表中优先级最高的任务，判断是否为当前任务，不是就切换
由  OSCtxSw() 实现
### OSIntExit()
#OSIntExit 
退出中断服务函数
中断级调度器
调用时会检测是否有中断锁，如果有则减去一层锁
若减去一层锁后中断完全解锁，则执行下面的步骤
确认调度器没有上锁
最后和非中断调度一致
由 #OSIntCtxSw()实现
### OS_SchedRoundRobin()
时间片轮转完后需要切换到下一个任务，同一优先级下切换到下一个任务，在OSTimeTick()或OS_IntQTask()中被调用。
检测轮询调度是否允许
检测任务时间片是否运行结束
调度器是否上锁
当前优先级下是否有其他任务
切换到下一个任务






# 任务切换
在不同的处理器上任务切换时各有不同，在移植时要根据具体情况修改 os_cpu.h os_cpu_c.c os_cpu_a.asm 
相关的数据结构为TCB.StkPtr ，指向RAM中的任务堆栈
CPU中的寄存器组，其中包含通用寄存器，R0-Rn若干个，中断寄存器ISP，程序计数器PC，状态寄存器SR等。

## OSCtxSw()
#OSCtxSw 
任务级优先调度器
将CPU中的寄存器存入TCP中任务堆栈指针指向的堆栈，先是状态寄存器和程序计数器，然后是通用寄存器
将堆栈指针的当前值存入 TCB.StkPtr7中
将新任务的StkPtr传给CPU的堆栈指针
通过堆栈指/-【针将其余任务寄存器读入 CPU 寄存器中
(##注意##：在存储任务寄存器时，是将CPU寄存器从任务的堆栈指针指向的位置开始存，然后CPU的堆栈指针根据存的情况+1或-1，然后将最后的CPU堆栈指针赋给TCB中的堆栈指针）


## OSIntCtxSw()
#OSIntCtxSw 
中断级调度器，流程与任务级相似，区别在于在进入中断时就已经保存了线程，此时只需要将新任务的寄存器从堆栈中交给CPU即可。
