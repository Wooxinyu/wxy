在正点原子直接访问资源共享区实验中，由于任务中使用了delaay_ms函数进行了延时，该函数中调用了delay_ostimedly函数，该函数调用了ucos提供的系统延时函数OSTimeDly，该函数延时受系统时钟节拍任务控制，因此会将任务变为延时态，任务被挂入系统时钟表等待延时结束，此时产生任务调度运行任务2，任务2再次修改共享资源区的内容后进入延时态，任务1延时结束后打印被任务2修改过的共享资源区内容。正点原子提供的delay_us并未调用系统延时函数，而是直接通过系统时钟进行延时，期间对调度器上锁，无法产生任务调度。如果将程序中delay_ms修改为delay_us，则不会产生上述的错误。
在任务访问一个共享资源时，希望这一次的访问是独占的，而不是在访问的过程中因为任务调度或者中断使此次访问过程被打断，同时出现另一个代码段来访问该资源。因此有些代码段应该作为不可分割的原子一样对待，任何代码一旦访问这些变量，就会对这些变量具有独享权。常用的独占共享资源和创建临界区的方法有开关中断，锁调度器，信号量与互斥信号量

#### 开关中断：
开关中断是一个任务和一个中断服务程序共享变量或结构体的唯一方法。
开关中断为CPU相关操作，并非任务级，关闭中断后，系统时钟节拍任务就无法正常的更新节拍信号，影响中断延时,从而影响系统对实时事件的响应能力。

#### 调度器上/开锁：
在调度器上锁但未关闭中断的情况下，一旦中断发生，即使在临界区内，中断服务程序也将被立即执行。即使中断函数使其他高优先级任务处于就绪态，中断结束后仍会回到被打断的任务中去。
调度器上锁最多可嵌套250层，只有全部开锁后才会进行正常的任务调度，进行任务切换。类似不可剥夺的内核。
不建议使用
#### 信号量SEM：

```
struct  os_sem {                                     
                                                           
    OS_OBJ_TYPE          Type;                              
    CPU_CHAR            *NamePtr;                           
    OS_PEND_LIST         PendList;                        
#if OS_CFG_DBG_EN > 0u
    OS_SEM              *DbgPrevPtr;
    OS_SEM              *DbgNextPtr;
    CPU_CHAR            *DbgNamePtr;
#endif
                                                     
    OS_SEM_CTR           Ctr;
    CPU_TS               TS;
};
```

结构体中的内容分别为类型，名字，等待列表，计数值，上一次被释放的时间
在用作共享资源时，只有!任务!才能使用信号量，中断服务程序则不能。用信号量收发信号时无从约束。
信号量是一种内核对象，在os_sem中定义，数据类型为OS_SEM
程序需先声明一个OS_SEM类型的变量作为信号量，调用OSSemCreate来创建信号量。信号量可以在启动任务中创建也可以在任务中创建，但要在被调用前创建。
可以自行定义该信号量的初始值，为1则为二值信号量。
请求和释放信号量的过程是相当耗费时间的，尽管关中断会导致一些间接成本，但在处理简单的共享变量时可以通过开关中断来提高整体的工作效率。
```
OS_SEM_CTR    OSSemPend                 (OS_SEM           * *p_sem,
                                         OS_TICK                timeout,
                                         OS_OPT                 opt,
                                         CPU_TS                *p_ts,
                                         OS_ERR                *p_err);
```

	p_sem为要等待的信号量
	timeout为等待时间
	opt为等待的模式，分为阻塞等待 OS_OPT_PEND_BLOCKING与非阻塞等待 OS_OPT_PEND_NON_BLOCKING。 使用信号量保护共享资源时一般选择阻塞。
	阻塞等待：如果信号量无效则会一直等下去 无效只请求的时候没有
	非阻塞等待：如果信号量无效则直接返回
	*p_ts 请求的信号量被释放的时间
	*p_err  返回的错误值

OS_SEM_CTR    OSSemPost                 (OS_SEM                *p_sem,
                                         OS_OPT                 opt,
                                         OS_ERR                *p_err);
	*p_sem为要释放的信号量
	opt为释放的模式，释放给单独的任务，释放给所有的任务，无调度的释放
	无调度的释放可以使任务一次性将所有信号量释放而避免被任务切换打断。
二进制信号量
	想要获取资源的任务必须执行等待操作。如果该资源对应的信号量有效，则信号量的值被设为0，任务继续执行。如果信号量值为0，则该任务进入等待状态，置入等待信号量任务表。
	允许定义超时，如果等待时间超过了某一设定值，则等待的任务会进入就绪态继续运行，并返回错误代码。
	任务以发信号操作释放信号量。如果没有任务等待该信号量，则信号量值设置为1.如果有，则等待中的优先级最高的任务进入就绪态，信号量值不变。如果就绪的任务优先级比释放信号量的任务优先级高，则会发生任务切换。即信号量的释放可能产生任务调度。
	任务需要共享I/O设备时，信号量尤为有用。
	最好把信号量藏起来，各任务在于某一资源打交道时，并不知道实际是在申请一个信号量？即在调用使用资源的函数时，在该函数中会请求信号量，并在调用完毕后释放。
计数性信号量
	取值范围由OS_SEM_CTR决定

#### 优先级反转
当高优先级任务所需要的资源正在被低优先级任务占用，高优先级任务并不能等到自己需要的资源，此时要等低优先级任务将资源释放后才能够继续执行，此时发生了优先级翻转。

#### 互斥信号量MUTEX
互斥信号量的机制是将占有共享资源的低优先级任务的优先级提升到和 等待该资源高优先级任务的优先级 一样高，使低优先级任务能尽快将资源使用完后释放掉，让高优先级任务获取资源的使用权。  在低优先级任务释放资源后，优先级会被恢复到原先的值。
互斥信号量支持嵌套，即一个任务中可以多次请求，但使用完资源后也要多次释放该信号量。
互斥信号量为二值信号量

#### 死锁
两个任务无限制地互相等待对方控制地资源。
假设任务T1通过信号量M1持有资源R1,任务T2通过信号量M2持有资源R2
T1要等待M2得到资源R2后才能继续运行，T2要等待M1得到资源R1后才能继续运行
此时两个任务相互抱死，即使通过互斥信号量也不能继续执行任务，都只能处于等待状态且解不开。
避免死锁地方法是让每个任务：
	先得到所需要地全部资源，再做下一步任务
	用相同的顺序申请多个资源
	在调用请求信号地函数时设定超时时间
